# Pending Changes System Implementation Roadmap (Granular Approach)

## Phase 1: Database Schema and Core Types

- [ ] **1.1. Update `pending_changes` Table Schema:**
    - Purpose: To store each individual suggested change as a separate, actionable row.
    - [ ] Remove existing `diff`, `ai_generated_template`, `base_template_for_diff` columns (if they were added from the previous plan).
    - [ ] **Add/Ensure Columns:**
        - [ ] `id`: Primary Key (e.g., UUID, auto-incrementing INT).
        - [ ] `project_id`: UUID, Foreign Key to `projects.id`.
        - [ ] `batch_id`: UUID. All granular changes generated from a single AI interaction will share the same `batch_id`.
        - [ ] `change_type`: VARCHAR. Enum-like: 'element_add', 'element_edit', 'element_delete', 'section_add', 'section_delete', 'section_edit'.
        - [ ] `target_id`: VARCHAR. The ID of the element or section being affected.
        - [ ] `target_parent_id`: VARCHAR (Nullable). For `element_add`, this is the `section_id` where the element should be added. For `section_add`, this could be null or indicate a parent section if nesting is supported (assume null for now).
        - [ ] `old_content`: JSONB (Nullable). For 'element_edit', 'element_delete', 'section_edit', 'section_delete'. Stores the full element/section object *before* the change.
        - [ ] `new_content`: JSONB (Nullable). For 'element_add', 'element_edit', 'section_add', 'section_edit'. Stores the full element/section object *after* the change (or the new object).
        - [ ] `status`: VARCHAR. Enum-like: 'pending', 'accepted', 'rejected'. Default: 'pending'.
        - [ ] `order_of_application`: INTEGER (Nullable). If the sequence of applying changes within a batch matters (e.g., add section before adding element to it), this can define the order. For now, assume independent changes or simple ordering by type (sections first).
        - [ ] `created_at`: TIMESTAMP WITH TIME ZONE. Default: `now()`.
        - [ ] `updated_at`: TIMESTAMP WITH TIME ZONE. Default: `now()`.
        - [ ] `ai_rationale`: TEXT (Nullable). Optional field for why AI suggested this specific change.

- [ ] **1.2. Update Shared Types (e.g., in `shared/types/pendingChangeTypes.ts`):**
    - [ ] Define `GranularPendingChange` type mirroring the new table structure.
    - [ ] `PendingChangeInput` might still be useful for the `applyPendingChanges`/`applyRevert` functions if they take a single change object.

## Phase 2: Modifying `generate-email-changes/index.ts`

- [ ] **2.1. Generation of Granular Changes:**
    - [ ] After `DifferV2().diffTemplates(currentV2Template, emailTemplateToUpdate)` produces `v2DiffResult`:
        - [ ] Generate a new `batch_id` (UUID) for this set of AI suggestions.
        - [ ] Implement logic (let's call it `convertDiffToGranularRows`) to iterate through `v2DiffResult.sectionDiffs` and `elementDiffs`.
        - [ ] For each distinct change identified in the diff, create a `GranularPendingChange` object according to the new schema.
            - **Section Add (`section_add`):**
                - `target_id`: `sectionDiff.sectionId` (from `emailTemplateToUpdate`).
                - `new_content`: Full section object from `emailTemplateToUpdate`.
                - `old_content`: null.
            - **Section Delete (`section_delete`):**
                - `target_id`: `sectionDiff.sectionId` (from `currentV2Template`).
                - `old_content`: Full section object from `currentV2Template`.
                - `new_content`: null.
            - **Section Edit (`section_edit`):** (If section properties themselves changed, not just elements within)
                - `target_id`: `sectionDiff.sectionId`.
                - `old_content`: Section object from `currentV2Template` (only properties, not elements list, or full section).
                - `new_content`: Section object from `emailTemplateToUpdate` (only properties, not elements list, or full section).
                - *Requires `DifferV2` to clearly distinguish section property changes from element changes within a section.* Assume for now: if `sectionDiff.status === 'modified'` but no `elementDiffs` or only some elements changed, the section properties might have changed.
            - **Element Add (`element_add`):**
                - `target_id`: `elementDiff.elementId` (from `emailTemplateToUpdate`).
                - `target_parent_id`: `sectionDiff.sectionId`.
                - `new_content`: Full element object from `emailTemplateToUpdate`.
                - `old_content`: null.
            - **Element Delete (`element_delete`):**
                - `target_id`: `elementDiff.elementId` (from `currentV2Template`).
                - `target_parent_id`: `sectionDiff.sectionId`.
                - `old_content`: Full element object from `currentV2Template` (augmented with `originalSectionId: sectionDiff.sectionId` if needed by `applyRevert`).
                - `new_content`: null.
            - **Element Edit (`element_edit`):**
                - `target_id`: `elementDiff.elementId`.
                - `target_parent_id`: `sectionDiff.sectionId`.
                - `old_content`: Full element object from `currentV2Template`.
                - `new_content`: Full element object from `emailTemplateToUpdate`.
        - [ ] All generated `GranularPendingChange` objects for this AI interaction get the same `batch_id` and `status: 'pending'`.

- [ ] **2.2. Saving Granular Changes:**
    - [ ] Instead of saving a single diff object, `generate-email-changes` will now perform a batch insert of all the generated `GranularPendingChange` rows into the `pending_changes` table.
    - [ ] The `projects` table is **not** updated by `generate-email-changes` at this stage. AI suggestions are only stored as pending.

- [ ] **2.3. Response from `generate-email-changes`:**
    - [ ] The function should return the `batch_id` and the array of `GranularPendingChange` objects it just created and saved. This allows the frontend to display them.

## Phase 3: Updating `manage-pending-changes/index.ts`

- Purpose: This function now handles actions on individual pending changes or batches of them.

- [ ] **3.1. Request Payload Adaptation:**
    - The request to `manage-pending-changes` will now need to specify:
        - `projectId: string`
        - `action: 'accept_one' | 'reject_one' | 'accept_batch' | 'reject_batch'`
        - `change_id: string` (Required if action is `accept_one` or `reject_one`. This is the `id` from the `pending_changes` table for a specific granular change).
        - `batch_id: string` (Required if action is `accept_batch` or `reject_batch`).

- [ ] **3.2. Helper: `applySingleChangeToTemplate`**
    - [ ] This will be a new helper or adapt existing `applyPendingChanges`.
    - **Signature:** `function applySingleChangeToTemplate(currentTemplate: EmailTemplateV2, singleChange: GranularPendingChange): EmailTemplateV2`
    - **Logic:** Based on `singleChange.change_type`, modify `currentTemplate` by applying the `new_content` or removing based on `old_content` and `target_id`.
        - This needs to correctly handle adding to/removing from section.elements, updating elements, adding/removing sections.
        - This is where the logic from the old `applyPendingChanges` (that took an array) can be adapted to handle one operation at a time carefully.

- [ ] **3.3. Helper: `revertSingleChangeInTemplate`** (Less likely needed if rejecting a pending change doesn't alter the main template)
    - If rejecting a single *pending* change means undoing it *from the current project template* (which implies it was somehow already applied for preview), then this is needed. Otherwise, rejecting a pending change just updates its status.
    - *Assumption:* Rejecting a *pending* item just changes its status; it doesn't alter the live project template.

- [ ] **3.4. Action: `accept_one`**
    - [ ] Fetch the specific `GranularPendingChange` row using `change_id`.
    - [ ] If its status is not `'pending'`, return an error/info (already processed).
    - [ ] Fetch the current `EmailTemplateV2` from `projects` table.
    - [ ] Apply this single change: `updatedTemplate = applySingleChangeToTemplate(currentProjectTemplate, fetchedChange)`. 
    - [ ] Generate new HTML for `updatedTemplate`.
    - [ ] Update the `projects` table: `semantic_email_v2 = updatedTemplate`, `current_html = newHtml`, `last_edited_at = now()`, (Consider if version increments here or only on batch accept).
    - [ ] Update the status of the `fetchedChange` row in `pending_changes` to `'accepted'`.
    - [ ] **Dependency/Staleness (Important):** Leave other pending changes in the same `batch_id` AS IS. They remain actionable.

- [ ] **3.5. Action: `reject_one`**
    - [ ] Fetch the specific `GranularPendingChange` row using `change_id`.
    - [ ] If its status is not `'pending'`, return an error/info.
    - [ ] Update the status of the `fetchedChange` row in `pending_changes` to `'rejected'`.
    - [ ] The `projects` table is NOT modified for this action.

- [ ] **3.6. Action: `accept_batch`**
    - [ ] Fetch all `GranularPendingChange` rows for the given `batch_id` that have `status = 'pending'`.
    - [ ] If no such rows, return info (nothing to accept).
    - [ ] Fetch the current `EmailTemplateV2` (`currentProjectTemplate`) from `projects` table.
    - [ ] **Order of Application:** If `order_of_application` is set, sort fetched changes by it. Otherwise, apply by type (e.g., section changes first, then element adds, then edits, then deletes - this needs careful thought).
    - [ ] Iterate through the sorted (or unsorted if order doesn't matter for independent changes) pending changes:
        - `currentProjectTemplate = applySingleChangeToTemplate(currentProjectTemplate, change_item)`.
    - [ ] `finalAcceptedBatchTemplate = currentProjectTemplate`.
    - [ ] Generate new HTML for `finalAcceptedBatchTemplate`.
    - [ ] Archive current state: Save the `EmailTemplateV2` (that was fetched *before* applying this batch) to `email_versions` table (associating it with the project's current version number *before* incrementing).
    - [ ] Update `projects` table: `semantic_email_v2 = finalAcceptedBatchTemplate`, `current_html = newHtml`, `last_edited_at = now()`, increment `version`.
    - [ ] Update the status of all processed `pending_changes` rows (those that were `'pending'` for this batch) to `'accepted'`.

- [ ] **3.7. Action: `reject_batch`**
    - [ ] Fetch all `GranularPendingChange` rows for the given `batch_id` with `status = 'pending'`.
    - [ ] If no such rows, return info.
    - [ ] Update the status of all these fetched rows in `pending_changes` to `'rejected'`.
    - [ ] The `projects` table is NOT modified for this action.

- [ ] **3.8. Refactor `applyPendingChanges` and `applyRevert` (from original `manage-pending-changes`):**
    - The old `applyPendingChanges` (which took an array) is essentially the loop logic needed for `accept_batch`.
    - The old `applyRevert` might be useful if we need to undo a batch of *already accepted* changes, but for rejecting *pending* changes, it's not directly used.

## Phase 4: Frontend Adaptations

- [ ] **4.1. Displaying Granular Pending Changes:**
    - [ ] Fetch granular changes (grouped by `batch_id`) for a project.
    - [ ] Render each change individually, showing what element/section it affects and the type of change (add, edit, delete).
    - [ ] Provide UI controls to `accept_one`, `reject_one` for each item.
    - [ ] Provide UI controls to `accept_batch`, `reject_batch` for each batch.
- [ ] **4.2. API Calls:**
    - [ ] Update frontend API calls to match the new request structure for `manage-pending-changes`.

## Phase 5: Testing and Refinement

- [ ] **5.1. Unit Tests:**
    - [ ] For `convertDiffToGranularRows` in `generate-email-changes`.
    - [ ] For `applySingleChangeToTemplate` in `manage-pending-changes`.
- [ ] **5.2. Integration Testing for all `manage-pending-changes` actions:**
    - [ ] `accept_one`: verify project update, status update of the one item.
    - [ ] `reject_one`: verify status update of the one item, no project change.
    - [ ] `accept_batch`: verify project update with all pending items in batch, status updates, versioning.
    - [ ] `reject_batch`: verify status updates of all pending items in batch, no project change.
    - [ ] Test scenarios where a user accepts one, then rejects others, then accepts the batch (ensure only remaining pending items are affected by batch action).
- [ ] **5.3. Review `order_of_application`:**
    - [ ] Determine if explicit ordering is needed for applying a batch of accepted changes or if logical grouping (sections then elements) is sufficient.

---
This revised map targets the granular approach. Key complexities will be in `convertDiffToGranularRows` and ensuring `applySingleChangeToTemplate` correctly modifies the template based on any single granular change type.
