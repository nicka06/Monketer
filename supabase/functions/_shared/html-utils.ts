import { EmailTemplate, EmailSection, EmailElement } from './types.ts';
// Remove the incorrect import of cleanUuid from types.ts
// import { cleanUuid } from './types.ts'; 
import { DOMParser } from 'https://deno.land/x/deno_dom/deno-dom-wasm.ts';
// Remove Deno std lib UUID import - use crypto.randomUUID() instead
// import { v4 } from "https://deno.land/std@0.168.0/uuid/mod.ts"; 
import { cleanUuid } from '@/lib/uuid-utils.ts'; // Import using import map

// Helper to convert camelCase style keys to kebab-case
function camelToKebab(str: string): string {
    return str.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
}

// Helper to generate inline style strings from style objects
function generateStyleString(styles?: Record<string, any>): string {
    if (!styles) return '';
    return Object.entries(styles)
        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)
        .join(' '); // Use space separation for inline styles
}

// --- ADD cleanUuid Function Here --- 
/**
 * Helper function to clean UUIDs that might have spaces or comments.
 * Often needed for IDs generated by AI.
 */
/* // Function moved to src/lib/uuid-utils.ts
function cleanUuid(id: string): string {
  if (!id || typeof id !== 'string') return ''; // Add type check
  
  // Remove any trailing digits or spaces
  const cleaned = id.replace(/\s+\d*$/, '').trim();
  
  // If it looks like a UUID, return it; otherwise return as is
  // Consider if non-UUIDs should be allowed or generate a new one?
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (uuidPattern.test(cleaned)) {
    return cleaned;
  }
  
  // If it doesn't look like a UUID, maybe log a warning or return original trimmed?
  console.warn(`[cleanUuid] Input ID "${id}" doesn't look like a valid UUID after cleaning.`);
  return id.trim(); // Return original trimmed ID if not UUID-like
}
*/

// --- ADD kebabToCamel Helper ---
// Helper to convert kebab-case (CSS) to camelCase (JS)
function kebabToCamel(str: string): string {
    return str.replace(/-([a-z])/g, (match, chr) => chr.toUpperCase());
}

// Main function to generate HTML from semantic structure
export async function generateHtmlFromSemantic(semanticEmail: EmailTemplate): Promise<string> {
    console.log("Generating HTML from semantic structure...");

    // Basic Email Wrapper - Using tables for better email client compatibility
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Email</title>
    <style>
        /* Basic Resets for email clients */
        body { margin: 0; padding: 0; font-family: sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        table { border-collapse: collapse; border-spacing: 0; }
        td { padding: 0; vertical-align: top; }
        img { border: 0; -ms-interpolation-mode: bicubic; max-width: 100%; }
        a { text-decoration: none; color: inherit; }
        /* Add specific global styles from semanticEmail.styles if needed */
        /* Example: body { ${generateStyleString(semanticEmail.styles?.global || {})} } */
    </style>
</head>
<body style="margin:0; padding:0; word-spacing:normal;">
    <table role="presentation" style="width:100%; border-collapse:collapse; border:0; border-spacing:0; background:#ffffff;">
        <tr>
            <td align="center" style="padding:0;">
                <!-- Main Content Wrapper Table -->
                <table role="presentation" style="width:602px; max-width: 602px; border-collapse:collapse; border:1px solid #cccccc; border-spacing:0; text-align:left;">
`;

    // Iterate through sections
    semanticEmail?.sections?.forEach((section: EmailSection) => {
        // Section wrapper (using table row/cell)
        html += `
                    <!-- Section Start: ${section.id} -->
                    <tr>
                        <td id="section-${section.id}" style="${generateStyleString(section.styles)}">
                            <!-- Inner table for content within section -->
                            <table role="presentation" style="width:100%; border-collapse:collapse; border:0; border-spacing:0;">
`;

        // Iterate through elements within the section
        section.elements?.forEach((element: EmailElement) => {
            const elementStyle = generateStyleString(element.styles);
            const elementId = element.id; // Use the element's ID directly

            html += `
                                <tr>
                                    <td style="padding:10px;">
                                        <!-- Element Start: ${elementId} -->
`; // Basic padding around elements

            // Generate HTML based on element type
            switch (element.type) {
                case 'header':
                    // Assuming H2 for headers, adjust level if needed
                    html += `<h2 id="${elementId}" style="margin:0; ${elementStyle}">${element.content || ''}</h2>`;
                    break;
                case 'text':
                    html += `<p id="${elementId}" style="margin:0; ${elementStyle}">${element.content || ''}</p>`;
                    break;
                case 'button':
                    // Buttons are tricky in email, often simulated with styled links in tables
                    html += `
                                        <table role="presentation" border="0" cellpadding="0" cellspacing="0" style="border-collapse: separate; mso-table-lspace: 0pt; mso-table-rspace: 0pt; width: auto;">
                                            <tr>
                                                <td id="${elementId}" style="${elementStyle} border-radius: 5px; text-align: center;" bgcolor="${element.styles?.backgroundColor || '#5cb85c'}">
                                                    <a href="${element.styles?.href || '#'}" target="_blank" style="display: inline-block; color: ${element.styles?.color || '#ffffff'}; background: ${element.styles?.backgroundColor || '#5cb85c'}; border: solid 1px ${element.styles?.borderColor || element.styles?.backgroundColor || '#5cb85c'}; border-radius: 5px; box-sizing: border-box; cursor: pointer; text-decoration: none; font-size: 14px; font-weight: bold; margin: 0; padding: 12px 25px; text-transform: capitalize; border-color: ${element.styles?.borderColor || element.styles?.backgroundColor || '#5cb85c'}; ">
                                                        ${element.content || 'Button Text'}
                                                    </a>
                                                </td>
                                            </tr>
                                        </table>
`;
                    break;
                case 'image':
                    html += `<img id="${elementId}" src="${element.content || 'placeholder.svg'}" alt="${element.styles?.alt || 'Image'}" width="${element.styles?.width || '100%'}" style="height: auto; display: block; ${elementStyle}" />`;
                    break;
                case 'divider':
                    html += `<hr id="${elementId}" style="border: none; border-top: 1px solid ${element.styles?.color || '#cccccc'}; margin: 10px 0; ${elementStyle}" />`;
                    break;
                case 'spacer':
                    // Use a div with height for spacer. Ensure line-height/font-size are set for outlook compatibility
                    html += `<div id="${elementId}" style="height: ${element.styles?.height || '20px'}; font-size: 1px; line-height: 1px; ${elementStyle}">&nbsp;</div>`; // Added &nbsp; for some clients
                    break;
                default:
                    html += `<div id="${elementId}" style="${elementStyle}">Unsupported element type: ${element.type} - Content: ${element.content || ''}</div>`;
            }

            html += `                                        <!-- Element End: ${elementId} -->
                                    </td>
                                </tr>
`;
        });

        // Close inner content table and section cell/row
        html += `
                            </table>
                        </td>
                    </tr>
                    <!-- Section End: ${section.id} -->
`;
    });

    // Close Main Content Wrapper Table and Body/HTML
    html += `
                </table>
                <!-- Main Content Wrapper Table END -->
            </td>
        </tr>
    </table>
</body>
</html>`;

    console.log("HTML generation complete.");
    return html;
}

// Add return type annotation
function renderElementToHtml(element: EmailElement): string {
    // ... (Existing implementation) ...
    if (element && element.id) {
        element.id = cleanUuid(element.id);
    }
    // ... rest of function ...
    return ""; // Placeholder - ensure original function returns string
}

// Add return type annotation
function styleObjectToString(styles: Record<string, string>): string {
    // ... (Existing implementation) ...
    return ""; // Placeholder - ensure original function returns string
}

// --- NEW HTML Parsing Logic --- 

/**
 * Parses an HTML string into a semantic EmailTemplate structure.
 * NOTE: This is a basic implementation and needs rules/heuristics 
 * to reliably map HTML elements back to the semantic model.
 */
export function parseHtmlToSemantic(htmlString: string): EmailTemplate {
    console.log("Starting HTML parsing...");
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlString, 'text/html');

    if (!doc || !doc.body) { // Check for body as well
        console.error("HTML Parsing Error: Failed to parse HTML string or body missing.");
        throw new Error("Failed to parse HTML string or body missing.");
    }

    const body = doc.body;
    console.log("Parsed Body OuterHTML:", body.outerHTML?.substring(0, 500) + "..."); 

    const sections: EmailSection[] = [];
    let templateName = doc.title || 'Untitled Email';
    console.log(`Template Name: ${templateName}`);

    let globalStyles: Record<string, any> | undefined = undefined;
    const styleTag = doc.head?.querySelector('style');
    if (styleTag && styleTag.textContent) {
        console.log("Found <style> tag in <head>. Extracting content.");
        globalStyles = { globalCss: styleTag.textContent.trim() };
    } else {
        console.log("No <style> tag found in <head> or it was empty.");
    }

    // --- Find the main content container ---
    let mainContentContainer: Element | null = null;

    // Priority 1: Look for our standard nested table structure
    mainContentContainer = body.querySelector('body > table > tr > td > table');
    if (mainContentContainer) {
        console.log("Found main content via standard table structure.");
    } else {
        console.warn("Standard table structure not found. Trying common div containers...");
        // Priority 2: Look for common container divs
        mainContentContainer = body.querySelector('div.email-container') 
                            || body.querySelector('div.container') 
                            || body.querySelector('div.wrapper')
                            || body.firstElementChild as Element; // Fallback to first direct child of body

        if (mainContentContainer && mainContentContainer.tagName !== 'SCRIPT' && mainContentContainer.tagName !== 'STYLE') {
             console.log(`Found potential main container: <${mainContentContainer.tagName.toLowerCase()}>`);
        } else {
             console.error("Failed to find a suitable main content container (table or div). Cannot extract sections/elements.");
             return { id: crypto.randomUUID(), name: templateName, sections: [], version: 1, styles: globalStyles };
        }
    }

    // --- Identify potential sections within the container ---
    // Sections could be direct children divs, or specific semantic tags
    // Let's prioritize direct children divs for now, but could expand later.
    // We need to handle the case where the container *is* the table body from our original structure.
    let potentialSectionElements: Element[] = [];
    if (mainContentContainer.tagName === 'TABLE') {
        // If it's the table structure, sections are <tr> -> <td>
         console.log("Container is a TABLE. Looking for section rows (tbody > tr)...");
         potentialSectionElements = Array.from(mainContentContainer.querySelectorAll(':scope > tbody > tr')) as Element[];
    } else {
        // If it's a div (or other container), treat its direct element children as potential sections
         console.log(`Container is <${mainContentContainer.tagName.toLowerCase()}>. Looking for direct element children...`);
         potentialSectionElements = Array.from(mainContentContainer.children);
    }
     console.log(`Found ${potentialSectionElements.length} potential section elements.`);


    potentialSectionElements.forEach((sectionElement, index) => {
        let sectionCell: HTMLElement | null = null; // The element holding the section's content and ID
        let actualSectionContentRoot: Element | null = null; // Where to look for elements within the section

        // Adapt based on whether the sectionElement is from our table structure (TR) or a direct div/etc.
        if (mainContentContainer?.tagName === 'TABLE' && sectionElement.tagName === 'TR') {
            // Original logic: Section data is in the first TD child
             sectionCell = sectionElement.firstElementChild as HTMLElement;
             if (sectionCell?.tagName !== 'TD') {
                 console.warn(`Skipping section row ${index + 1}: Expected first child to be TD, found ${sectionCell?.tagName}`);
                 sectionCell = null; // Ensure it's null if not a TD
             } else {
                 // Elements are inside a nested table: TD > table
                  actualSectionContentRoot = sectionCell.querySelector(':scope > table');
                  if (!actualSectionContentRoot) {
                       console.warn(`Section ${index + 1}: Could not find nested element table inside the TD.`);
                  }
             }
        } else if (mainContentContainer?.tagName !== 'TABLE') {
             // New logic: Treat the direct child div/element itself as the section container
             sectionCell = sectionElement as HTMLElement; // Use the element itself for ID/styles
             actualSectionContentRoot = sectionElement; // Look for elements directly within it
             console.log(`Treating <${sectionCell.tagName.toLowerCase()}> as section ${index + 1}`);
        }

        if (!sectionCell) {
             console.warn(`Skipping potential section ${index + 1}: Could not determine valid section cell/container.`);
            return; // Skip this iteration
        }

        // --- Section ID --- 
        const rawSectionId = sectionCell.getAttribute('id')?.replace('section-', '') || sectionCell.getAttribute('data-section-id') || ''; // Allow data-attribute?
        const cleanedSectionId = cleanUuid(rawSectionId);
        const finalSectionId = cleanedSectionId || crypto.randomUUID(); 
        console.log(` Section ID: ${finalSectionId} (Raw: ${rawSectionId}, Cleaned: ${cleanedSectionId})`);

        // --- Section Styles --- 
        const sectionStyleString = sectionCell.getAttribute('style') || '';
        const sectionStyles = parseStyles(sectionStyleString);
        // Consider parsing class styles later if needed

        const currentSection: EmailSection = {
            id: finalSectionId,
            styles: sectionStyles,
            elements: [],
        };

        // --- Find Elements within the Section ---
        if (!actualSectionContentRoot) {
             console.warn(`Section ${finalSectionId}: No valid root element found to search for content elements.`);
        } else {
            // Find potential elements within the determined root
            // Let's look for direct children first, might need refinement
            // Adapt based on whether we are in the table structure or div structure
            let potentialElements: Element[] = [];
             if (mainContentContainer?.tagName === 'TABLE' && actualSectionContentRoot.tagName === 'TABLE') {
                  // Original logic: Elements are in table > tbody > tr > td > [content element]
                   potentialElements = Array.from(actualSectionContentRoot.querySelectorAll(':scope > tbody > tr')); // Get the rows
                   console.log(`  Searching for elements within TABLE structure (found ${potentialElements.length} rows)`);
             } else {
                   // New logic: Look for direct children of the section div
                    potentialElements = Array.from(actualSectionContentRoot.children);
                    console.log(`  Searching for elements within <${actualSectionContentRoot.tagName.toLowerCase()}> structure (found ${potentialElements.length} direct children)`);
             }


            potentialElements.forEach((elementContainer, elIndex) => {
                 let contentElement : HTMLElement | null = null;

                 // Adapt how we find the *actual* content element
                  if (mainContentContainer?.tagName === 'TABLE' && elementContainer.tagName === 'TR') {
                       // Original: TR > TD > first element child
                        const elementCell = elementContainer.firstElementChild as HTMLElement;
                       if (elementCell?.tagName === 'TD') {
                           contentElement = elementCell.firstElementChild as HTMLElement;
                       } else {
                            console.warn(`   Skipping element row ${elIndex + 1}: Expected TD, found ${elementCell?.tagName}`);
                       }
                  } else {
                       // New: Treat the direct child itself as the content element
                        contentElement = elementContainer as HTMLElement;
                  }


                 if (contentElement) {
                     console.log(`   Processing element ${elIndex + 1}: <${contentElement.tagName.toLowerCase()}>, ID: ${contentElement.getAttribute('id')}, OuterHTML: ${contentElement.outerHTML?.substring(0, 100)}...`);
                     try {
                         const type = detectElementType(contentElement);
                         if (type !== 'unknown') {
                             let elementId = contentElement.getAttribute('id') || contentElement.getAttribute('data-element-id') || '';
                             let cleanedId = cleanUuid(elementId);
                             const finalId = cleanedId || crypto.randomUUID();
                             
                             const styleString = contentElement.getAttribute('style') || '';
                             let styles = parseStyles(styleString);
                             // TODO: Parse styles from classes if needed
                             
                             const content = extractElementContent(contentElement, type);

                             // Special handling for buttons might need adjustment for div structure
                             if (type === 'button' && contentElement.tagName !== 'TABLE') {
                                // If it's an <a> tag detected as a button, extract href etc.
                                 if(contentElement.tagName === 'A') {
                                     styles.href = contentElement.getAttribute('href') || '#';
                                     // Potentially parse styles from its classes?
                                 }
                                 // Need to decide how to handle button styles if not in table
                             } else if (type === 'button' && contentElement.tagName === 'TABLE') {
                                 // Existing table-based button logic
                                  const link = contentElement.querySelector('a'); 
                                  const buttonTd = contentElement.querySelector('td');
                                  // ... (rest of existing button logic) ...
                                   let finalButtonStyles: Record<string, string> = {};
                                   if (buttonTd) {
                                       finalButtonStyles = parseStyles(buttonTd.getAttribute('style') || '');
                                       const tdBgColor = buttonTd.getAttribute('bgcolor');
                                       if (tdBgColor && !finalButtonStyles.backgroundColor) {
                                           finalButtonStyles.backgroundColor = tdBgColor;
                                       }
                                   }
                                   let aStyles: Record<string, string> = {};
                                   if (link) {
                                       styles.href = link.getAttribute('href') || '#'; 
                                       aStyles = parseStyles(link.getAttribute('style') || '');
                                   }
                                   finalButtonStyles = { ...finalButtonStyles, ...aStyles }; 
                                   styles = finalButtonStyles;
                             } else if (type === 'image') {
                                  styles.alt = contentElement.getAttribute('alt') || '';
                                  styles.width = contentElement.getAttribute('width') || 'auto'; 
                                  styles.height = contentElement.getAttribute('height') || 'auto';
                              } 
                              // Add other type-specific style extractions if needed

                             currentSection.elements.push({
                                 id: finalId,
                                 type: type,
                                 content: content,
                                 styles: styles,
                             });
                              console.log(`    Added element: ${type} (ID: ${finalId})`);
                         } else {
                              console.warn(`    Skipping unknown element type for tag: ${contentElement.tagName}`);
                         }
                     } catch (parseError) {
                          console.error(`    Error processing element ${elIndex + 1} (Tag: ${contentElement.tagName}):`, parseError);
                     }
                 } else {
                     console.warn(`   Skipping potential element ${elIndex + 1}: Could not identify content element.`);
                 }
            });
        } // End of element processing within section
        
        // Only add section if it contains elements (or maybe allow empty sections?)
        if (currentSection.elements.length > 0) {
            sections.push(currentSection);
            console.log(`Finished processing section ${finalSectionId}, added ${currentSection.elements.length} elements.`);
        } else {
             console.log(`Skipping section ${finalSectionId} as no elements were parsed.`);
        }

    }); // End of section processing

    console.log(`HTML parsing finished. Found ${sections.length} sections.`);
    // Construct the final EmailTemplate object
    const semanticEmail: EmailTemplate = {
        id: crypto.randomUUID(), 
        name: templateName,
        sections: sections,
        version: 1,
        styles: globalStyles, 
    };

    return semanticEmail;
}

/**
 * Parses an inline CSS style string into a Record<string, string>.
 * Converts kebab-case properties to camelCase.
 */
function parseStyles(styleString: string): Record<string, string> {
    const styles: Record<string, string> = {};
    if (!styleString) {
        return styles;
    }

    styleString.split(';').forEach(declaration => {
        if (declaration.trim()) {
            const [rawKey, ...valueParts] = declaration.split(':');
            const key = rawKey?.trim();
            const value = valueParts.join(':').trim(); 

            if (key && value) {
                 const camelCaseKey = kebabToCamel(key);
                 styles[camelCaseKey] = value;
            }
        }
    });

    return styles;
}

/**
 * Attempts to detect the semantic element type based on the HTML element.
 * Needs to be more flexible.
 */
function detectElementType(element: HTMLElement): EmailElement['type'] | 'unknown' {
    const tagName = element.tagName.toLowerCase();
     const elementClass = element.className || ''; // Get class attribute

    switch (tagName) {
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
            return 'header';
        case 'p':
            return 'text';
        case 'img':
            return 'image';
        case 'hr':
            return 'divider';
         case 'a': // Treat styled links as buttons
             // Heuristic: If it has common button classes or significant styling
             if (elementClass.includes('button') || element.getAttribute('style')?.includes('background-color')) {
                 return 'button';
             }
             // Otherwise, it might just be a link within text (handled by extractElementContent using innerHTML)
             // Let's assume for now if it's a standalone <a> it's intended as a button-like CTA
             return 'button'; 
        case 'table':
            // Check for our specific button table structure first
            const buttonLink = element.querySelector(':scope > tbody > tr > td > a'); 
            if (buttonLink) {
                return 'button';
            }
             // Could be a layout table, treat as unknown for now, or try parsing its content?
             return 'unknown'; 
        case 'div':
             // Check if it looks like a spacer (has height style, empty content)
             const styles = parseStyles(element.getAttribute('style') || '');
             const innerHTML = element.innerHTML?.trim() || '';
             if (styles.height && (innerHTML === '' || innerHTML === '&nbsp;')) {
                return 'spacer';
             }
             // Check if it acts as a divider (e.g., class="divider")
             if (elementClass.includes('divider')) {
                 return 'divider';
             }
             // Basic check for div containing only text/inline elements -> treat as text
             // This might be too broad, but let's try it
             if (Array.from(element.childNodes).every(cn => cn.nodeType === cn.TEXT_NODE || (
                  cn.nodeType === cn.ELEMENT_NODE && 
                  ['span', 'strong', 'em', 'i', 'b', 'u', 'a'].includes((cn as Element).tagName.toLowerCase())
                 )))
             {
                 // Check if it only contains &nbsp; or is empty, could be a spacer
                 if (innerHTML === '' || innerHTML === '&nbsp;') {
                     // If it also has height style, it was caught above. If not, maybe still a spacer?
                     if(styles.height) return 'spacer'; // Redundant but safe
                 } else {
                    return 'text'; // Contains actual text or inline elements
                 }
             }
             // If it contains block elements like <p>, <h1> etc., it's likely a structural container, not a text block itself
             if (element.querySelector('p, h1, h2, h3, h4, h5, h6, img, table, hr, ul, ol')) {
                  return 'unknown'; // Treat as container/unknown, elements inside will be processed
             }

             // Fallback if it's not clearly a spacer, divider, or text container
             return 'unknown';
        case 'span': // Treat span containing text as text
             // Check if it's essentially empty (might be used for spacing tricks)
             const spanInnerHTML = element.innerHTML?.trim() || '';
             if (spanInnerHTML === '' || spanInnerHTML === '&nbsp;') {
                 // Could check for height/width styles to classify as spacer? For now, unknown.
                  return 'unknown'; 
             }
             return 'text'; 
        default:
            return 'unknown';
    }
}

/**
 * Extracts the relevant content for a given element type.
 */
function extractElementContent(element: HTMLElement, type: EmailElement['type']): string {
    // Existing logic seems mostly okay, but adjust button extraction
    switch (type) {
        case 'header':
        case 'text':
            return element.innerHTML?.trim() || '';
        case 'button': 
            // If it's our table structure, use the link text
            if (element.tagName === 'TABLE') {
                const buttonLink = element.querySelector('a'); 
                return buttonLink?.textContent?.trim() || '';
            } 
            // If it's an <a> tag directly identified as a button
            else if (element.tagName === 'A') {
                 return element.textContent?.trim() || '';
            }
            // Fallback for other potential button structures?
            return element.textContent?.trim() || ''; 
        case 'image':
            return element.getAttribute('src') || '';
        case 'divider':
        case 'spacer':
             return ''; 
        default:
             console.warn(`[extractElementContent] Unknown type "${type}" for element ${element.tagName}. Returning textContent.`);
            return element.textContent?.trim() || '';
    }
}

// Assume cleanUuid might be needed here or is imported correctly
// Example cleanUuid (if not imported from types.ts)
/*
function cleanUuid(id: string): string {
    // ... implementation ...
}
*/ 