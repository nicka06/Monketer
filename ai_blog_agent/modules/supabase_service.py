# supabase_service.py 
"""
Handles formatting of blog post data and posting it to a Supabase Edge Function.

This module is responsible for:
- Transforming blog components (title, slug, content, etc.) into the JSON payload 
  expected by the Supabase 'create-blog-post' Edge Function.
- Sending the formatted payload to the configured Supabase Edge Function URL.
- Handling responses and errors from the Supabase Edge Function.
"""

import os
import yaml # For loading config if we need SUPABASE_FUNCTION_URL later
from dotenv import load_dotenv # If we need API keys for direct calls later
import json # For serializing payload to JSON
import requests # For making HTTP POST request
import logging # For logging

# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Utility to load config (primarily for SUPABASE_FUNCTION_URL if needed in future functions)
def load_config():
    """Loads the YAML configuration file."""
    # Adjust path to be relative to this file's location or use an absolute path
    config_path = os.path.join(os.path.dirname(__file__), '..', 'config.yaml')
    try:
        with open(config_path, 'r') as stream:
            return yaml.safe_load(stream)
    except FileNotFoundError:
        logging.error(f"Configuration file not found at {config_path}")
        return None
    except yaml.YAMLError as exc:
        logging.error(f"Error parsing YAML configuration: {exc}")
        return None

def format_for_supabase(blog_post_components: dict) -> dict:
    """
    Formats the blog post data generated by the writing_service into the JSON payload
    expected by the 'create-blog-post' Supabase Edge Function.

    Args:
        blog_post_components: A dictionary from writing_service containing:
                              - title (str)
                              - slug (str)
                              - content (str) (Markdown)
                              - category (str|None)
                              - excerpt (str|None)

    Returns:
        A dictionary formatted for the Supabase function.
    """
    logging.info(f"[Supabase Service] Formatting data for Supabase for slug: {blog_post_components.get('slug')}")

    # Default author for now, will be updated after Telegram confirmation in later phases
    default_author = "AI Agent"
    
    # Ensure all expected keys from blog_post_components are present, providing defaults if necessary
    formatted_payload = {
        "title": blog_post_components.get("title", "Default Title - Check Generation"),
        "slug": blog_post_components.get("slug", "default-slug-check-generation"),
        "content": blog_post_components.get("content", "Default Content - Check Generation"),
        "author_id": default_author, # Changed 'author' to 'author_id'
        # "category": blog_post_components.get("category"), # Removed as per user's table schema
        "excerpt": blog_post_components.get("excerpt"),   # Will be None if not generated
        "featured_image_url": None,  # Changed 'image_url' to 'featured_image_url'; Not generating images in this phase
        "published_at": None # Signifies a draft or not yet published
        # Add status field here if your Supabase table/function supports it e.g. "status": "draft"
        # Consider adding "is_published": False if needed by the table/function for drafts
    }
    
    # Remove keys with None values if the Supabase function prefers them omitted rather than null
    # For now, we'll send them as nulls as Supabase handles that for nullable fields.
    # payload_cleaned = {k: v for k, v in formatted_payload.items() if v is not None}

    logging.info("[Supabase Service] Data formatted successfully.")
    return formatted_payload

def post_blog_to_supabase(payload: dict) -> dict:
    """
    Posts the formatted blog data to the Supabase Edge Function.

    Args:
        payload: A dictionary containing the formatted blog post data.

    Returns:
        A dictionary containing the response from the Supabase function (e.g., the created post)
        or an error message if the post fails.
    """
    logging.info(f"[Supabase Service] Attempting to post blog with slug: {payload.get('slug')}")
    config = load_config()
    if not config or 'supabase_function' not in config or 'url' not in config['supabase_function']:
        logging.error("[Supabase Service] Supabase function URL not found in config.yaml.")
        return {"error": "Supabase function URL not configured."}

    function_url = config['supabase_function']['url']
    # Headers can be extended from config if needed (e.g., for Authorization)
    headers = config['supabase_function'].get('headers', {})
    headers['Content-Type'] = 'application/json' # Ensure Content-Type is set

    try:
        response = requests.post(function_url, data=json.dumps(payload), headers=headers, timeout=30)
        response.raise_for_status()  # Raises an HTTPError for bad responses (4XX or 5XX)
        
        # Check if response content is not empty before trying to parse JSON
        if response.content:
            response_data = response.json()
            logging.info(f"[Supabase Service] Successfully posted blog. Response slug: {response_data.get('slug')}")
            return response_data
        else:
            # Handle cases where the response is successful (e.g. 201 Created) but has no body
            # Though our Edge Function is expected to return the created post (status 201)
            logging.info("[Supabase Service] Successfully posted blog, but response body was empty.")
            return {"success": True, "message": "Post created, no content in response", "status_code": response.status_code}

    except requests.exceptions.HTTPError as http_err:
        error_message = f"HTTP error occurred: {http_err}"
        if http_err.response is not None and http_err.response.content:
            try:
                error_body = http_err.response.json()
                error_message += f" - Server response: {error_body.get('error', http_err.response.text)}"
            except json.JSONDecodeError:
                error_message += f" - Server response (not JSON): {http_err.response.text}"
        logging.error(f"[Supabase Service] {error_message}")
        return {"error": error_message, "status_code": http_err.response.status_code if http_err.response else None}
    except requests.exceptions.RequestException as req_err:
        logging.error(f"[Supabase Service] Request exception occurred: {req_err}")
        return {"error": f"Request failed: {req_err}"}
    except Exception as e:
        logging.error(f"[Supabase Service] An unexpected error occurred during Supabase post: {e}")
        return {"error": f"An unexpected error: {e}"} 